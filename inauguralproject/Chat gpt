import numpy as np
from scipy.optimize import minimize_scalar

# Set baseline parameters
rho = 2
nu = 0.001
epsilon = 1
omega = 0.5
alpha_values = [0.25, 0.5, 0.75]
sigma_values = [0.5, 1.0, 1.5]
w_M = 1
w_F = 1

# Define household production function
def home_production(H_M, H_F, alpha, sigma):
    if sigma == 0:
        return min(H_M, H_F)
    elif sigma == 1:
        return (H_M**(1-alpha))*(H_F**alpha)
    else:
        return ((1-alpha)*(H_M**((sigma-1)/sigma))+alpha*(H_F**((sigma-1)/sigma)))**(sigma/(sigma-1))

# Define objective function
def objective(x):
    L_M = x[0]
    H_M = x[1]
    L_F = x[2]
    H_F = x[3]
    C = w_M*L_M + w_F*L_F
    H = home_production(H_M, H_F, alpha, sigma)
    Q = C**omega * H**(1-omega)
    T_M = L_M + H_M
    T_F = L_F + H_F
    return -(Q**(1-rho)/(1-rho) - nu*(T_M**(1+1/epsilon)/(1+1/epsilon) + T_F**(1+1/epsilon)/(1+1/epsilon)))

# Define choice set
choice_set = np.arange(0, 24.5, 0.5)

# Iterate over alpha and sigma values
for alpha in alpha_values:
    for sigma in sigma_values:
        # Define bounds
        bounds = [(0, 24), (0, 24), (0, 24), (0, 24)]
        # Solve maximization problem
        result = minimize_scalar(lambda x: objective([x[0], x[1], x[2], x[3]]), bounds=bounds, method='bounded')
        # Compute value of H_F/H_M
        H_F_H_M = result.x[3]/result.x[1]
        # Print result
        print("alpha = {:.2f}, sigma = {:.1f}, H_F/H_M = {:.2f}".format(alpha, sigma, H_F_H_M))
